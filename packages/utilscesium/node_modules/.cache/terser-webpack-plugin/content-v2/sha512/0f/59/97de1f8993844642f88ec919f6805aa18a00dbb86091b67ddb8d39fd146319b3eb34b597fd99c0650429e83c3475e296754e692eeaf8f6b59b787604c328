{"code":"!function(n){var e={};function t(i){if(e[i])return e[i].exports;var r=e[i]={i:i,l:!1,exports:{}};return n[i].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=n,t.c=e,t.d=function(n,e,i){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:i})},t.r=function(n){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(n,\"__esModule\",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&\"object\"==typeof n&&n&&n.__esModule)return n;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,\"default\",{enumerable:!0,value:n}),2&e&&\"string\"!=typeof n)for(var r in n)t.d(i,r,function(e){return n[e]}.bind(null,r));return i},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,\"a\",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p=\"\",t(t.s=0)}([function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"// ESM COMPAT FLAG\\n__webpack_require__.r(__webpack_exports__);\\n\\n// EXPORTS\\n__webpack_require__.d(__webpack_exports__, \\\"Collection\\\", function() { return /* reexport */ src_Collection; });\\n__webpack_require__.d(__webpack_exports__, \\\"Coordinate\\\", function() { return /* reexport */ /* Cannot get final name for export \\\"default\\\" in \\\"./src/Coordinate.js\\\" (known exports: fromCartesian3 fromCartesian3Array, known reexports: ) */ undefined; });\\n__webpack_require__.d(__webpack_exports__, \\\"OverlayPositioning\\\", function() { return /* reexport */ src_OverlayPositioning; });\\n__webpack_require__.d(__webpack_exports__, \\\"Overlay\\\", function() { return /* reexport */ src_Overlay; });\\n__webpack_require__.d(__webpack_exports__, \\\"Viewer\\\", function() { return /* reexport */ src_Viewer; });\\n\\n// CONCATENATED MODULE: ./src/Collection.js\\n/**\\r\\n * 参考ol.Collection\\r\\n * @module utilscesium/Collection\\r\\n */\\n\\n/**\\r\\n * @enum {string}\\r\\n * @private\\r\\n */\\nconst Property = {\\n  LENGTH: 'length'\\n};\\n/**\\r\\n * @classdesc\\r\\n * 集合\\r\\n * @api\\r\\n */\\n\\nclass Collection {\\n  /**\\r\\n   * 构造函数\\r\\n   * @param {Array<T>=} opt_array Array.\\r\\n   * @param {Options=} opt_options Collection options.\\r\\n   */\\n  constructor(opt_array, opt_options) {\\n    //super();\\n    const options = opt_options || {};\\n    this.prototype = {};\\n    /**\\r\\n     * @private\\r\\n     * @type {boolean}\\r\\n     */\\n\\n    this.unique_ = !!options.unique;\\n    /**\\r\\n     * @private\\r\\n     * @type {!Array<T>}\\r\\n     */\\n\\n    this.array_ = opt_array ? opt_array : [];\\n\\n    if (this.unique_) {\\n      for (let i = 0, ii = this.array_.length; i < ii; ++i) {\\n        this.assertUnique_(this.array_[i], i);\\n      }\\n    }\\n\\n    this.updateLength_();\\n    this.addEvent_ = new Cesium.Event();\\n    this.removeEvent_ = new Cesium.Event();\\n  }\\n  /**\\r\\n   * 删除集合所元素\\r\\n   * @api\\r\\n   */\\n\\n\\n  clear() {\\n    while (this.getLength() > 0) {\\n      this.pop();\\n    }\\n  }\\n  /**\\r\\n  * Add elements to the collection.  This pushes each item in the provided array\\r\\n  * to the end of the collection.\\r\\n  * @param {!Array<T>} arr Array.\\r\\n  * @return {Collection<T>} This collection.\\r\\n  * @api\\r\\n  */\\n\\n\\n  extend(arr) {\\n    for (let i = 0, ii = arr.length; i < ii; ++i) {\\n      this.push(arr[i]);\\n    }\\n\\n    return this;\\n  }\\n  /**\\r\\n  * Iterate over each element, calling the provided callback.\\r\\n  * @param {function(T, number, Array<T>): *} f The function to call\\r\\n  *     for every element. This function takes 3 arguments (the element, the\\r\\n  *     index and the array). The return value is ignored.\\r\\n  * @api\\r\\n  */\\n\\n\\n  forEach(f) {\\n    const array = this.array_;\\n\\n    for (let i = 0, ii = array.length; i < ii; ++i) {\\n      f(array[i], i, array);\\n    }\\n  }\\n  /**\\r\\n  * Get a reference to the underlying Array object. Warning: if the array\\r\\n  * is mutated, no events will be dispatched by the collection, and the\\r\\n  * collection's \\\"length\\\" property won't be in sync with the actual length\\r\\n  * of the array.\\r\\n  * @return {!Array<T>} Array.\\r\\n  * @api\\r\\n  */\\n\\n\\n  getArray() {\\n    return this.array_;\\n  }\\n  /**\\r\\n  * Get the element at the provided index.\\r\\n  * @param {number} index Index.\\r\\n  * @return {T} Element.\\r\\n  * @api\\r\\n  */\\n\\n\\n  item(index) {\\n    return this.array_[index];\\n  }\\n  /**\\r\\n  * Get the length of this collection.\\r\\n  * @return {number} The length of the array.\\r\\n  * @observable\\r\\n  * @api\\r\\n  */\\n\\n\\n  getLength() {\\n    return this.get(Property.LENGTH);\\n  }\\n  /**\\r\\n  * Insert an element at the provided index.\\r\\n  * @param {number} index Index.\\r\\n  * @param {T} elem Element.\\r\\n  * @api\\r\\n  */\\n\\n\\n  insertAt(index, elem) {\\n    if (this.unique_) {\\n      this.assertUnique_(elem);\\n    }\\n\\n    this.array_.splice(index, 0, elem);\\n    this.updateLength_();\\n    this.addEvent_.raiseEvent({\\n      type: \\\"add\\\",\\n      element: elem,\\n      index: index\\n    }); //this.dispatchEvent(\\n    //    new CollectionEvent(CollectionEventType.ADD, elem, index));\\n  }\\n  /**\\r\\n  * Remove the last element of the collection and return it.\\r\\n  * Return `undefined` if the collection is empty.\\r\\n  * @return {T|undefined} Element.\\r\\n  * @api\\r\\n  */\\n\\n\\n  pop() {\\n    return this.removeAt(this.getLength() - 1);\\n  }\\n  /**\\r\\n   * Insert the provided element at the end of the collection.\\r\\n   * @param {T} elem Element.\\r\\n   * @return {number} New length of the collection.\\r\\n   * @api\\r\\n   */\\n\\n\\n  push(elem) {\\n    if (this.unique_) {\\n      this.assertUnique_(elem);\\n    }\\n\\n    const n = this.getLength();\\n    this.insertAt(n, elem);\\n    return this.getLength();\\n  }\\n  /**\\r\\n   * Remove the first occurrence of an element from the collection.\\r\\n   * @param {T} elem Element.\\r\\n   * @return {T|undefined} The removed element or undefined if none found.\\r\\n   * @api\\r\\n   */\\n\\n\\n  remove(elem) {\\n    const arr = this.array_;\\n\\n    for (let i = 0, ii = arr.length; i < ii; ++i) {\\n      console.log(arr[i] === elem);\\n\\n      if (arr[i] === elem) {\\n        return this.removeAt(i);\\n      }\\n    }\\n\\n    return undefined;\\n  }\\n  /**\\r\\n   * Remove the element at the provided index and return it.\\r\\n   * Return `undefined` if the collection does not contain this index.\\r\\n   * @param {number} index Index.\\r\\n   * @return {T|undefined} Value.\\r\\n   * @api\\r\\n   */\\n\\n\\n  removeAt(index) {\\n    const prev = this.array_[index];\\n    this.array_.splice(index, 1);\\n    this.updateLength_(); //this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));\\n\\n    this.removeEvent_.raiseEvent({\\n      type: \\\"remove\\\",\\n      element: prev,\\n      index: index\\n    });\\n    return prev;\\n  }\\n  /**\\r\\n   * Set the element at the provided index.\\r\\n   * @param {number} index Index.\\r\\n   * @param {T} elem Element.\\r\\n   * @api\\r\\n   */\\n\\n\\n  setAt(index, elem) {\\n    const n = this.getLength();\\n\\n    if (index < n) {\\n      if (this.unique_) {\\n        this.assertUnique_(elem, index);\\n      }\\n\\n      const prev = this.array_[index];\\n      this.array_[index] = elem;\\n      this.removeEvent_.raiseEvent({\\n        type: \\\"remove\\\",\\n        element: prev,\\n        index: index\\n      });\\n      this.addEvent_.raiseEvent({\\n        type: \\\"add\\\",\\n        element: elem,\\n        index: index\\n      }); //this.dispatchEvent(\\n      //    new CollectionEvent(CollectionEventType.REMOVE, prev, index));\\n      //this.dispatchEvent(\\n      //    new CollectionEvent(CollectionEventType.ADD, elem, index));\\n    } else {\\n      for (let j = n; j < index; ++j) {\\n        this.insertAt(j, undefined);\\n      }\\n\\n      this.insertAt(index, elem);\\n    }\\n  }\\n  /**\\r\\n   * @private\\r\\n   */\\n\\n\\n  updateLength_() {\\n    this.set(Property.LENGTH, this.array_.length);\\n  }\\n\\n  get(name) {\\n    return this.prototype[name];\\n  }\\n\\n  set(name, value) {\\n    this.prototype[name] = value;\\n\\n    if (Cesium.defined(this[\\\"changed\\\" + name])) {\\n      this[\\\"changed\\\" + name].raiseEvent({\\n        type: \\\"changed\\\" + name\\n      });\\n    }\\n  }\\n\\n}\\n\\n/* harmony default export */ var src_Collection = (Collection);\\n// CONCATENATED MODULE: ./src/Coordinate.js\\n/**\\r\\n * @module utilscesium/Coordinate\\r\\n */\\n\\n/**\\r\\n * 表示xy坐标的数字数组. 例如: `[16, 48]`.\\r\\n * @typedef {Array<number>} Coordinate\\r\\n * @api\\r\\n */\\n\\n/**\\r\\n * cartesian3转为[x,y]\\r\\n * @param {module:Cesium/Cartesian3} cartesian3\\r\\n */\\nfunction fromCartesian3(cartesian3) {\\n  let ellipsoid = Cesium.Ellipsoid.WGS84;\\n  let cartographic = ellipsoid.cartesianToCartographic(cartesian3);\\n  let lon = Cesium.Math.toDegrees(cartographic.longitude);\\n  let lat = Cesium.Math.toDegrees(cartographic.latitude);\\n  return [lon, lat];\\n}\\n/**\\r\\n * cartesian3数组转为[x,y]数组\\r\\n * @param {Array.<module:Cesium.Cartesian3>} cartesian3Array \\r\\n */\\n\\nfunction fromCartesian3Array(cartesian3Array) {\\n  let ellipsoid = Cesium.Ellipsoid.WGS84;\\n  let coordinates = [];\\n\\n  for (let i = 0; i < cartesian3Array.length; i++) {\\n    let cartesian3 = cartesian3Array[i];\\n    let cartographic = ellipsoid.cartesianToCartographic(cartesian3);\\n    let lon = Cesium.Math.toDegrees(cartographic.longitude);\\n    let lat = Cesium.Math.toDegrees(cartographic.latitude);\\n    coordinates.push([lon, lat]);\\n  }\\n\\n  return coordinates;\\n}\\n// CONCATENATED MODULE: ./src/OverlayPositioning.js\\n/**\\r\\n * @module utilscesium/OverlayPositioning \\r\\n */\\n\\n/**\\r\\n * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,\\r\\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\\r\\n * `'top-center'`, `'top-right'`\\r\\n * @enum {string}\\r\\n * @api\\r\\n */\\nconst OverlayPositioning = {\\n  BOTTOM_LEFT: 'bottom-left',\\n  BOTTOM_CENTER: 'bottom-center',\\n  BOTTOM_RIGHT: 'bottom-right',\\n  CENTER_LEFT: 'center-left',\\n  CENTER_CENTER: 'center-center',\\n  CENTER_RIGHT: 'center-right',\\n  TOP_LEFT: 'top-left',\\n  TOP_CENTER: 'top-center',\\n  TOP_RIGHT: 'top-right'\\n};\\n/* harmony default export */ var src_OverlayPositioning = (OverlayPositioning);\\n// CONCATENATED MODULE: ./src/Overlay.js\\n/**\\r\\n * @module utilscesium/Overlay\\r\\n */\\n\\nconst Overlay_Property = {\\n  ELEMENT: 'element',\\n  VIEWER: 'viewer',\\n  OFFSET: 'offset',\\n  POSITION: 'position',\\n  POSITIONING: 'positioning'\\n};\\n/**\\r\\n * @classdesc\\r\\n * 覆盖物(参考openlayers,基础功能已经实现)\\r\\n * @api\\r\\n */\\n\\nclass Overlay_Overlay {\\n  /**\\r\\n   * 构造函数\\r\\n   * @param {Object} opt_options\\r\\n   * @param {Element} [opt_options.element] html元素\\r\\n   * @param {offset} [opt_options.offset]  偏移\\r\\n   * @param {utilscesium.OverlayPositioning} [opt_options.positioning]  覆盖物相对点的位置\\r\\n   * @param {boolean} [opt_options.stopEvent] \\r\\n   * @param {boolean} [opt_options.insertFirst] 是否插入首位\\r\\n   * @param {boolean} [opt_options.autoPan]\\r\\n   * @param {Object} [opt_options.autoPanAnimation]\\r\\n   * @param {number} [opt_options.autoPanMargin]\\r\\n   */\\n  constructor(opt_options) {\\n    let options = Object.assign({\\n      element: null,\\n      offset: [0, 0],\\n      positioning: \\\"center-left\\\",\\n      stopEvent: false,\\n      insertFirst: false,\\n      autoPan: false,\\n      autoPanAnimation: {},\\n      autoPanMargin: 20\\n    }, opt_options);\\n    this.prototype = {};\\n    this.id = options.id;\\n    this.insertFirst = options.insertFirst;\\n    this.stopEvent = options.stopEvent;\\n    this.element = document.createElement('div');\\n    this.element.className = options.className !== undefined ? options.className : 'cesium-overlay-container ol-selectable';\\n    this.element.style.position = 'absolute';\\n    this.autoPan = options.autoPan;\\n    this.autoPanAnimation = options.autoPanAnimation;\\n    this.autoPanMargin = options.autoPanMargin;\\n    this.rendered = {\\n      bottom_: '',\\n      left_: '',\\n      right_: '',\\n      top_: '',\\n      visible: true\\n    };\\n    this.viewerPostrenderListenerKey = null;\\n    this.changedelement = new Cesium.Event();\\n    this.changedelement.addEventListener(this.handleElementChanged.bind(this));\\n    this.changedoffset = new Cesium.Event();\\n    this.changedoffset.addEventListener(this.handleOffsetChanged.bind(this));\\n    this.changedposition = new Cesium.Event();\\n    this.changedposition.addEventListener(this.handlePositionChanged.bind(this));\\n    this.changedpositioning = new Cesium.Event();\\n    this.changedpositioning.addEventListener(this.handlePositioningChanged.bind(this));\\n    this.changedviewer = new Cesium.Event();\\n    this.changedviewer.addEventListener(this.handleViewerChanged.bind(this));\\n\\n    if (Cesium.defined(options.element)) {\\n      this.setElement(options.element);\\n    }\\n\\n    this.setOffset(Cesium.defined(options.offset) ? options.offset : [0, 0]);\\n    this.setPositioning(Cesium.defined(options.positioning) ? options.positioning : \\\"top-left\\\");\\n\\n    if (Cesium.defined(options.position)) {\\n      this.setPosition(options.position);\\n    }\\n  }\\n\\n  getElement() {\\n    return this.get(Overlay_Property.ELEMENT);\\n  }\\n\\n  getId() {\\n    return this.id;\\n  }\\n\\n  getViewer() {\\n    return this.get(Overlay_Property.VIEWER);\\n  }\\n\\n  getOffset() {\\n    return this.get(Overlay_Property.OFFSET);\\n  }\\n\\n  getPosition() {\\n    return this.get(Overlay_Property.POSITION);\\n  }\\n\\n  getPositioning() {\\n    return this.get(Overlay_Property.POSITIONING);\\n  }\\n\\n  handleElementChanged() {\\n    this.element.innerHTML = \\\"\\\";\\n    const element = this.getElement();\\n\\n    if (element) {\\n      this.element.appendChild(element);\\n    }\\n  }\\n  /**\\r\\n  * @protected\\r\\n  */\\n\\n\\n  handleViewerChanged() {\\n    const viewer = this.getViewer();\\n\\n    if (viewer) {\\n      viewer.scene.postRender.addEventListener(this.render.bind(this)); //viewer.scene.postUpdate.addEventListener(this.render.bind(this));\\n\\n      this.updatePixelPosition();\\n      const container = this.stopEvent ? viewer.getOverlayContainerStopEvent() : viewer.getOverlayContainer();\\n\\n      if (this.insertFirst) {\\n        container.insertBefore(this.element, container.childNodes[0] || null);\\n      } else {\\n        container.appendChild(this.element);\\n      }\\n    }\\n  }\\n\\n  render() {\\n    this.updatePixelPosition();\\n  }\\n\\n  handleOffsetChanged() {\\n    this.updatePixelPosition();\\n  }\\n\\n  handlePositionChanged() {\\n    this.updatePixelPosition(); //if (this.get(Property.POSITION) && this.autoPan) {\\n    //    this.panIntoView();\\n    //}\\n  }\\n\\n  handlePositioningChanged() {\\n    this.updatePixelPosition();\\n  }\\n\\n  setElement(element) {\\n    this.set(Overlay_Property.ELEMENT, element);\\n  }\\n  /**\\r\\n   * 绑定viewer\\r\\n   * @param {module:Cesium/Viewer} viewer\\r\\n   */\\n\\n\\n  setViewer(viewer) {\\n    this.set(Overlay_Property.VIEWER, viewer); //super.setViewer(viewer);\\n    //this.init();\\n  }\\n\\n  setOffset(offset) {\\n    this.set(Overlay_Property.OFFSET, offset);\\n  }\\n\\n  setPosition(position) {\\n    this.set(Overlay_Property.POSITION, position);\\n  }\\n\\n  setPositioning(positioning) {\\n    this.set(Overlay_Property.POSITIONING, positioning);\\n  }\\n\\n  setVisible(visible) {\\n    if (this.rendered.visible !== visible) {\\n      this.element.style.display = visible ? '' : 'none';\\n      this.rendered.visible = visible;\\n    }\\n  }\\n\\n  updatePixelPosition() {\\n    const viewer = this.getViewer();\\n    const position = this.getPosition();\\n\\n    if (!viewer || !position) {\\n      this.setVisible(false);\\n      return;\\n    }\\n\\n    const p = viewer.scene.cartesianToCanvasCoordinates(position);\\n\\n    if (!Cesium.defined(p)) {\\n      console.error(\\\"p is undefined\\\");\\n      return;\\n    }\\n\\n    const pixel = [p.x, p.y];\\n    const mapSize = [viewer._cesiumWidget.canvas.width, viewer._cesiumWidget.canvas.height];\\n    this.updateRenderedPosition(pixel, mapSize);\\n  }\\n\\n  updateRenderedPosition(pixel, mapSize) {\\n    const style = this.element.style;\\n    const offset = this.getOffset();\\n    const positioning = this.getPositioning();\\n    this.setVisible(true);\\n    let offsetX = offset[0];\\n    let offsetY = offset[1];\\n\\n    if (positioning == src_OverlayPositioning.BOTTOM_RIGHT || positioning == src_OverlayPositioning.CENTER_RIGHT || positioning == src_OverlayPositioning.TOP_RIGHT) {\\n      if (this.rendered.left_ !== '') {\\n        this.rendered.left_ = '';\\n        style.left = '';\\n      }\\n\\n      const right = Math.round(mapSize[0] - pixel[0] - offsetX) + 'px';\\n\\n      if (this.rendered.right_ != right) {\\n        this.rendered.right_ = right;\\n        style.right = right;\\n      }\\n    } else {\\n      if (this.rendered.right_ !== '') {\\n        this.rendered.right_ = '';\\n        style.right = '';\\n      }\\n\\n      if (positioning == src_OverlayPositioning.BOTTOM_CENTER || positioning == src_OverlayPositioning.CENTER_CENTER || positioning == src_OverlayPositioning.TOP_CENTER) {\\n        offsetX -= this.element.offsetWidth / 2;\\n      }\\n\\n      const left = Math.round(pixel[0] + offsetX) + 'px';\\n\\n      if (this.rendered.left_ != left) {\\n        this.rendered.left_ = left;\\n        style.left = left;\\n      }\\n    }\\n\\n    if (positioning == src_OverlayPositioning.BOTTOM_LEFT || positioning == src_OverlayPositioning.BOTTOM_CENTER || positioning == src_OverlayPositioning.BOTTOM_RIGHT) {\\n      if (this.rendered.top_ !== '') {\\n        this.rendered.top_ = '';\\n        style.top = '';\\n      }\\n\\n      const bottom = Math.round(mapSize[1] - pixel[1] - offsetY) + 'px';\\n\\n      if (this.rendered.bottom_ != bottom) {\\n        this.rendered.bottom_ = bottom;\\n        style.bottom = bottom;\\n      }\\n    } else {\\n      if (this.rendered.bottom_ !== '') {\\n        this.rendered.bottom_ = '';\\n        style.bottom = '';\\n      }\\n\\n      if (positioning == src_OverlayPositioning.CENTER_LEFT || positioning == src_OverlayPositioning.CENTER_CENTER || positioning == src_OverlayPositioning.CENTER_RIGHT) {\\n        offsetY -= this.element.offsetHeight / 2;\\n      }\\n\\n      const top = Math.round(pixel[1] + offsetY) + 'px';\\n\\n      if (this.rendered.top_ != top) {\\n        this.rendered.top_ = 'top';\\n        style.top = top;\\n      }\\n    }\\n  }\\n\\n  get(name) {\\n    return this.prototype[name];\\n  }\\n\\n  set(name, value) {\\n    this.prototype[name] = value;\\n\\n    if (Cesium.defined(this[\\\"changed\\\" + name])) {\\n      this[\\\"changed\\\" + name].raiseEvent({\\n        type: \\\"changed\\\" + name\\n      });\\n    }\\n  }\\n\\n}\\n\\n/* harmony default export */ var src_Overlay = (Overlay_Overlay);\\n// CONCATENATED MODULE: ./src/Viewer.js\\n/**\\r\\n * @module utilscesium/Viewer\\r\\n */\\n\\n\\nclass Viewer_Viewer extends Cesium.Viewer {\\n  constructor(container, opt_options) {\\n    let options = Object.assign({}, opt_options);\\n    super(container, options);\\n  }\\n  /**\\r\\n   * 根据id获取图层\\r\\n   * @param {any} layerId\\r\\n   */\\n\\n\\n  getLayerById(layerId) {\\n    let layers = this.imageryLayers._layers;\\n\\n    for (let i = 0; i < layers.length; i++) {\\n      let layer = layers[i];\\n\\n      if (layer.id == layerId) {\\n        return layer;\\n      }\\n    }\\n  }\\n\\n  addOverlay(overlay) {\\n    if (!Cesium.defined(this.overlayContainer_)) {\\n      this.overlayContainer_ = document.createElement('div');\\n      this.overlayContainer_.style.position = 'absolute';\\n      this.overlayContainer_.style.zIndex = '0';\\n      this.overlayContainer_.style.width = '100%';\\n      this.overlayContainer_.style.height = '100%';\\n      this.overlayContainer_.style.top = \\\"0\\\";\\n      this.overlayContainer_.style.left = \\\"0\\\";\\n      this.overlayContainer_.style.pointerEvents = \\\"none\\\";\\n      this.overlayContainer_.className = 'cesium-overlaycontainer';\\n      this.container.appendChild(this.overlayContainer_);\\n    }\\n\\n    if (!Cesium.defined(this.overlayContainerStopEvent_)) {\\n      this.overlayContainerStopEvent_ = document.createElement('div');\\n      this.overlayContainerStopEvent_.style.position = 'absolute';\\n      this.overlayContainerStopEvent_.style.zIndex = '0';\\n      this.overlayContainerStopEvent_.style.width = '100%';\\n      this.overlayContainerStopEvent_.style.height = '100%';\\n      this.overlayContainerStopEvent_.style.top = \\\"0\\\";\\n      this.overlayContainerStopEvent_.style.left = \\\"0\\\";\\n      this.overlayContainerStopEvent_.style.pointerEvents = \\\"none\\\";\\n      this.overlayContainerStopEvent_.className = 'cesium-overlaycontainer-stopevent';\\n      this.container.appendChild(this.overlayContainerStopEvent_);\\n    }\\n\\n    if (!Cesium.defined(this.overlays_)) {\\n      this.overlays_ = new src_Collection();\\n      this.overlays_.addEvent_.addEventListener(function (event) {\\n        event.element.setViewer(this);\\n        console.log(this.overlays_.getArray());\\n      }.bind(this));\\n      this.overlays_.removeEvent_.addEventListener(function (event) {\\n        console.log(event);\\n        const overlay = event.element;\\n        const id = overlay.getId();\\n        overlay.setViewer(null);\\n      }.bind(this));\\n    } //overlay.setViewer(this);\\n\\n\\n    return this.getOverlays().push(overlay);\\n  }\\n\\n  removeOverlay(overlay) {\\n    return this.getOverlays().remove(overlay);\\n  }\\n\\n  getOverlayContainerStopEvent() {\\n    return this.overlayContainerStopEvent_;\\n  }\\n\\n  getOverlayContainer() {\\n    return this.overlayContainer_;\\n  }\\n\\n  getOverlays() {\\n    return this.overlays_;\\n  }\\n\\n}\\n\\n/* harmony default export */ var src_Viewer = (Viewer_Viewer);\\n// CONCATENATED MODULE: ./src/index.js\\n/**\\r\\n * @module utilscesium\\r\\n */\\n\\n\\n\\n\\n\\n\\n//# sourceURL=webpack:///./src/index.js_+_5_modules?\")}]);","extractedComments":[]}